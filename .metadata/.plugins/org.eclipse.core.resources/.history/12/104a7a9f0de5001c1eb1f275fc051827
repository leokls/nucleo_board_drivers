// BHM Engineering Academy
// https://cortex-m.com/lessons/
// Embedded Systems Bare-Metal Programming Ground Upâ„¢ (STM32)

#include "stm32f4xx.h"
#include "adc.h"

#define GPIOAEN		    (1U<<0)
#define ADC1EN			(1U<<8)
#define ADC_CH1			(1U<<0)
#define ADC_SEQ_LEN_1	 0x00
#define CR2_AD0N		(1U<<0)
#define CR2_SWSTART		(1U<<30)
#define CR2_CONT		(1U<<1)
#define CR1_EOCIE		(1U<<5)   // Bit 5 ADC_CR1 EOCIE

void pa1_adc_interrupt_init(void)
{
	// ------ Configure the ADC GPIO pin.

	// 1. Enable clock access to GPIOA.
	RCC->AHB1ENR |= GPIOAEN;

	// 2. Set the mode of PA1 to analog mode.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 8.4.1 GPIO port mode register GPIOx_MODER
	// Bits 2 and 3. 11: Analog mode.
	GPIOA->MODER |= (1U << 2);
	GPIOA->MODER |= (1U << 3);

	// ------ Configure the ADC peripheral.
	// 1. Enable clock access to ADC.
	RCC->APB2ENR |= ADC1EN;

    // ------
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 11.12.2 ADC control register 1 (ADC_CR1).
	// Bit 5 EOCIE: Interrupt enable for End-of-Conversion.
	ADC1->CR1 |= CR1_EOCIE;

	// core m-4
	NVIC_EnableIRQ(ADC_IRQn);

	// ------

	// 2. Configure the ADC parameters.
	// 2a. Conversion sequence start.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 11.12.11 ADC regular sequence register 3 ADC_SQR3.
	// There's single channel - placed in SQ1[4:0].
	ADC1->SQR3 = ADC_CH1;

	// 2b. Conversion sequence end.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 11.12.9 ADC regular sequence register 1 (ADC_SQR1).
	// Regular channel sequence length L[3:0], bits 20 to 23.
	// 0000: 1 conversion.
	ADC1->SQR1 = ADC_SEQ_LEN_1;

	// 3. Enable the ADC peripheral.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 11.12.3 ADC control register 2 (ADC_CR2)
	// Bit 0 ADON (A/D converter ON/OFF):
	// 0 disable ADC conversion; 1: enable ADC.
	ADC1->CR2 |= CR2_AD0N;
}

//void pa1_adc_init(void)
//{
//	/***Configure the ADC GPIO pin ***/
//
//	/*Enable clock access to GPIOA*/
//	RCC->AHB1ENR |= GPIOAEN;
//
//	/*Set the mode of PA1 to analog*/
//	GPIOA->MODER |=(1U<<2);
//	GPIOA->MODER |=(1U<<3);
//	/***Configure the ADC module***/
//	/*Enable clock access to ADC */
//	RCC->APB2ENR |= ADC1EN;
//
//	/*Conversion sequence start*/
//	ADC1->SQR3 = ADC_CH1;
//
//	/*Conversion sequence length*/
//	ADC1->SQR1 = ADC_SEQ_LEN_1;
//
//	/*Enable ADC module*/
//	ADC1->CR2 |= CR2_AD0N;
//}
//
//
//void start_converstion(void)
//{
//	/*Enable continuous conversion*/
//	ADC1->CR2 |= CR2_CONT;
//	/*Start adc conversion*/
//	ADC1->CR2 |= CR2_SWSTART;
//}



uint32_t adc_read(void)
{
	// Wait before the conversion has completed.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	while(!(ADC1->SR & SR_EOC)){}

	// Read the result of conversion.
	return (ADC1->DR);
}
