#include "uart.h"

#define GPIOAEN			(1U<<0)
#define UART2EN			(1U<<17)

#define CR1_TE			(1U<<3)
#define CR1_RE			(1U<<2)

#define CR1_UE			(1U<<13)
#define SR_TXE			(1U<<7)
#define CR1_RXNEIE		(1U<<5)

#define SYS_FREQ		16000000
#define APB1_CLK		SYS_FREQ

#define UART_BAUDRATE		115200

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk,  uint32_t BaudRate);
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate);

void uart2_rx_interrupt_init(void)
{
	// ------ Configure the UART GPIO pin
	// 1. Enable the clock access to GPIOA
	RCC->AHB1ENR |= GPIOAEN;

	// TX init
	// 2. Set PA2 mode to alternate function mode.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 8.4.1 GPIO port mode register GPIOx_MODER
	// Pin 2 requires MODER2[1:0] at bits 4 and 5.
	// 10: Alternate function mode.
	GPIOA->MODER &= ~(1U << 4);
	GPIOA->MODER |= (1U << 5);

	// 3. Set PA2 alternate function type to UART_TX (AF07)
	// 8.4.9 GPIO alternate function low register (GPIOx_AFRL)
	// AFRL register contains AFRL0[3:0] through ARFL7[3:0].
	// Pin 2 uses ARFL2[3:0].
	// Alternate function selection 0111: AF7
	GPIOA->AFR[0] |= (1U << 8);    // AFR[0] maps to AFR low.
	GPIOA->AFR[0] |= (1U << 9);
	GPIOA->AFR[0] |= (1U << 10);
	GPIOA->AFR[0] &= ~(1U << 11);

	// RX init
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// MODER3[1:0] is located at bits 7 and 6.
	// Bits 2y: 2y+1: 3*2 : 3*2 + 1 = 6 : 7.
	// Set bit 6 to 0, bit 7 to 1: Alternate function mode
	// 4. Set PA3 to alternate function mode
	GPIOA->MODER &= ~(1U << 6);
	GPIOA->MODER |= (1U << 7);

	// 5. Set PA3 alternate function type to UART_RX
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 8.4.9. GPIOx_AFRL3[3:0] set to 0111: AF7
	GPIOA->AFR[0] |= (1U << 12);  // AFR[0] maps to AFR low.
	GPIOA->AFR[0] |= (1U << 13);
	GPIOA->AFR[0] |= (1U << 14);
	GPIOA->AFR[0] &= ~(1U << 15);

	/****************Configure uart module ***************/
	/*Enable clock access to uart2 */
	// 1. Enable the clock access to UART2
	RCC->APB1ENR |= UART2EN;

	// 2. Configure the Baudrate.
	// Derive an equation empirically.
	uart_set_baudrate(USART2, APB1_CLK, UART_BAUDRATE);

	// 3. Configure the transfer direction.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 19.6.4 Control register 1 (USART_CR1).
	// Bit 3: TE. Transmitter enable: 0: disabled, 1: enabled.
	// Set the default state of the UART transmitter:
	// Data width: 8 bits. USART_CR1 bit 12: M, word length.
	// 0: 1 start bit, 8 data bits, n stop bit.
	// Default number of stop and end bits and parity.
	// The number of stop bits is configured in CR2:
	// 19.6.5 Control register 2 (USART_CR2)
	// Bits 13:12, 00: 1 stop bit.
	// Hardware stop control is disabled.
	// Parity is set to even.
	// Set TE to 1, and make every other bit 0 to use the default settings.
	// Don't need to configure the USART2_CR2 register.
	// Bit 2 RE: receiver enable.
	USART2->CR1 = (CR1_TE | CR1_RE);         // enable transmitter and receiver.

	// 4. Enable the RXNE interrupt
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	// 19.6.4 Control register 1 (USART_CR1).
	// Bit 5: RXNEIE: RXNE interrupt enable.
	// 1: an USART interrupt is generated whenever ORE = 1 or RXNE = 1
	// in the USART_SR register.
	USART2->CR1 |= CR1_RXNEIE;

	 // 5. Enable the UART2 interrupt in NVIC
	 NVIC_EnableIRQ(USART2_IRQn);

	 // 6. Enable the UART module.
	 // RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
	 // 19.6.4 Control register 1 (USART_CR1).
	 // Bit 13 UE: USART enable.
	 USART2->CR1 |= CR1_UE;        // |= add the USART enable bit.
}

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk,  uint32_t BaudRate)
{
	USARTx->BRR = compute_uart_bd(PeriphClk,BaudRate);
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate)
{
	return ((PeriphClk + (BaudRate/2U))/BaudRate);
}
