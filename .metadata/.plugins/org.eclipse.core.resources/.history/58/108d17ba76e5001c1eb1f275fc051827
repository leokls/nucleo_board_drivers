// BHM Engineering Academy
// https://cortex-m.com/lessons/
// Embedded Systems Bare-Metal Programming Ground Upâ„¢ (STM32)

#include "uart.h"

#define GPIOAEN						(1U<<0)
#define UART2EN						(1U<<17)

#define CR1_TE						(1U<<3)
#define CR1_RE						(1U<<2)

#define CR1_UE						(1U<<13)
#define SR_TXE						(1U<<7)
#define CR1_RXNEIE					(1U<<5)

#define	DMA1EN						(1U<<21)
#define CHSEL4						(1U<<27)
#define DMA_MEM_INC					(1U<<10)
#define DMA_DIR_MEM_TO_PERIPH		(1U<<6)
#define DMA_CR_TCIE				    (1U<<4)
#define DMA_CR_EN				    (1U<<0)
#define UART_CR3_DMAT				(1U<<7)

#define SYS_FREQ					16000000
#define APB1_CLK					SYS_FREQ

#define UART_BAUDRATE				115200

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk,  uint32_t BaudRate);
static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate);

void uart2_write(int ch);

int __io_putchar(int ch)
{
	uart2_write(ch);
	return ch;
}

// // RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF
// Table 27. DMA1 request mapping (STM32F411xC/E)
// Channel 4, Stream 6
void dma1_stream6_init(uint32_t src, uint32_t dst, uint32_t len)
{
	// 1. Enable the clock access to DMA.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF.
	// 9.5.5 DMA Stream x configuration register (DMA_SxCR).
	// Bit 12 DMA1 clock enable
	RCC->AHB1ENR |= DMA1EN;

	// 2. Disable the DMA Stream 6.
	DMA1_Stream6->CR &= ~DMA_CR_EN;

    // 3. Wait before DMA1 Stream 6 has been disabled.
	while(DMA1_Stream6->CR & DMA_CR_EN){}

	// 4. Clear Stream 6's interrupt flags
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF.
	// 9.5.4 DMA high interrupt flag clear register (DMA_HIFCR).
	// DMA high interrupt flag clear register (DMA_HIFCR).
	DMA1->HIFCR |= (1U << 16);
	DMA1->HIFCR |= (1U << 18);
	DMA1->HIFCR |= (1U << 19);
	DMA1->HIFCR |= (1U << 20);
	DMA1->HIFCR |= (1U << 21);

	// 5. Configure the destination buffer.
	// 9.5.7 DMA stream x peripheral address register
	// (DMA_SxPAR)
	DMA1_Stream6->PAR = dst;

	// 6. Configure the source buffer.
	// 9.5.8 DMA stream x memory 0 address register.
	// DMA_SxM0AR.
	DMA1_Stream6->M0AR = src;

	// 7. Configure the length.
	DMA1_Stream6->NDTR = len;

	// 8. Select Stream 6's channel 4.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF.
	// 9.5.5 DMA stream x configuration register (DMA_SxCR).
	// Bits 25-27, channel select: 100: channel 4 select.
	DMA1_Stream6->CR = CHSEL4;

	// 9. Enable the memory increment.
	// RM0383-STM32F411XCE-REFERENCE-MANUAL.PDF.
	// MSIZE[1:0] bits 13, 14.
	// MINC -- memory increment mode, bit 10.
	DMA1_Stream6->CR |= DMA_MEM_INC;

	// 10. Configure the data transfer destination.
	// Bits 7:6 DIR[1:0] Data transfer direction.
	// 01: Memory-to-peripheral.
	// 10: Memory-to-memory.
	DMA1_Stream6->CR |= DMA_DIR_MEM_TO_PERIPH;

	// 11. Enable the DMA transfer complete interrupt.
	// 9.5.5 DMA stream x configuration register (DMA_SxCR).
	// Bit 1. DMEIE: Direct mode error interrupt enable.
	// Bit 2. TEIE: Transfer error interrupt enable.
	// Bit 3. HTIE: Half transfer interrupt enable.
	// Bit 4. TCIE: Transfer complete interrupt enable.
	DMA1_Stream6->CR |= DMA_CR_TCIE;

	// 12. Enable direct mode and disable FIFO.
	// 9.5.10 DMA stream x FIFO control register (DMA_SxFCR).
	// 0: FE disabled.
	// Bit 2: DMDIS Direct mode disable.
	DMA1_Stream6->FCR = 0;

	// 13. Enable DMA1 Stream6.
	//
	DMA1_Stream6->CR |=DMA_CR_EN;

	// 14. Enable UART2 transmitter DMA.
	//
	USART2->CR3 |=UART_CR3_DMAT;

	// 15. DMA Interrupt enable in NVIC.
	//
	NVIC_EnableIRQ(DMA1_Stream6_IRQn);
}

void uart2_rxtx_init(void)
{
	/****************Configure uart gpio pin***************/
	/*Enable clock access to gpioa */
	RCC->AHB1ENR |= GPIOAEN;

	/*Set PA2 mode to alternate function mode*/
	GPIOA->MODER &=~(1U<<4);
	GPIOA->MODER |= (1U<<5);

	/*Set PA2 alternate function type to UART_TX (AF07)*/
	GPIOA->AFR[0] |= (1U<<8);
	GPIOA->AFR[0] |= (1U<<9);
	GPIOA->AFR[0] |= (1U<<10);
	GPIOA->AFR[0] &= ~(1U<<11);

	/*Set PA3 mode to alternate function mode*/
	GPIOA->MODER &=~(1U<<6);
	GPIOA->MODER |= (1U<<7);

	/*Set PA3 alternate function type to UART_RX (AF07)*/
	GPIOA->AFR[0] |= (1U<<12);
	GPIOA->AFR[0] |= (1U<<13);
	GPIOA->AFR[0] |= (1U<<14);
	GPIOA->AFR[0] &= ~(1U<<15);

	/****************Configure uart module ***************/
	/*Enable clock access to uart2 */
	RCC->APB1ENR |= UART2EN;

	/*Configure baudrate*/
	uart_set_baudrate(USART2,APB1_CLK,UART_BAUDRATE);

	/*Configure the transfer direction*/
	 USART2->CR1 =  (CR1_TE | CR1_RE);

	/*Enable uart module*/
	 USART2->CR1 |= CR1_UE;
}

void uart2_rx_interrupt_init(void)
{
	/****************Configure uart gpio pin***************/
	/*Enable clock access to gpioa */
	RCC->AHB1ENR |= GPIOAEN;

	/*Set PA2 mode to alternate function mode*/
	GPIOA->MODER &=~(1U<<4);
	GPIOA->MODER |= (1U<<5);

	/*Set PA2 alternate function type to UART_TX (AF07)*/
	GPIOA->AFR[0] |= (1U<<8);
	GPIOA->AFR[0] |= (1U<<9);
	GPIOA->AFR[0] |= (1U<<10);
	GPIOA->AFR[0] &= ~(1U<<11);

	/*Set PA3 mode to alternate function mode*/
	GPIOA->MODER &=~(1U<<6);
	GPIOA->MODER |= (1U<<7);

	/*Set PA3 alternate function type to UART_RX (AF07)*/
	GPIOA->AFR[0] |= (1U<<12);
	GPIOA->AFR[0] |= (1U<<13);
	GPIOA->AFR[0] |= (1U<<14);
	GPIOA->AFR[0] &= ~(1U<<15);

	/****************Configure uart module ***************/
	/*Enable clock access to uart2 */
	RCC->APB1ENR |= UART2EN;

	/*Configure baudrate*/
	uart_set_baudrate(USART2,APB1_CLK,UART_BAUDRATE);

	/*Configure the transfer direction*/
	 USART2->CR1 =  (CR1_TE | CR1_RE);

	 /*Enable RXNE inteerupt*/
	 USART2->CR1 |=CR1_RXNEIE;

	 /*Enable UART2 interrupt in NVIC*/
	 NVIC_EnableIRQ(USART2_IRQn);

	/*Enable uart module*/
	 USART2->CR1 |= CR1_UE;
}

void uart2_tx_init(void)
{
	/****************Configure uart gpio pin***************/
	/*Enable clock access to gpioa */
	RCC->AHB1ENR |= GPIOAEN;

	/*Set PA2 mode to alternate function mode*/
	GPIOA->MODER &=~(1U<<4);
	GPIOA->MODER |= (1U<<5);

	/*Set PA2 alternate function type to UART_TX (AF07)*/
	GPIOA->AFR[0] |= (1U<<8);
	GPIOA->AFR[0] |= (1U<<9);
	GPIOA->AFR[0] |= (1U<<10);
	GPIOA->AFR[0] &= ~(1U<<11);

	/****************Configure uart module ***************/
	/*Enable clock access to uart2 */
	RCC->APB1ENR |= UART2EN;

	/*Configure baudrate*/
	uart_set_baudrate(USART2,APB1_CLK,UART_BAUDRATE);

	/*Configure the transfer direction*/
	 USART2->CR1 =  CR1_TE;

	/*Enable uart module*/
	 USART2->CR1 |= CR1_UE;
}


char uart2_read(void)
{
	  /*Make sure the receive data register is not empty*/
	while(!(USART2->SR & SR_RXNE)){}

	/*Read data*/
	return USART2->DR;

}

void uart2_write(int ch)
{
  /*Make sure the transmit data register is empty*/
	while(!(USART2->SR & SR_TXE)){}

  /*Write to transmit data register*/
	USART2->DR	=  (ch & 0xFF);
}

static void uart_set_baudrate(USART_TypeDef *USARTx, uint32_t PeriphClk,  uint32_t BaudRate)
{
	USARTx->BRR =  compute_uart_bd(PeriphClk,BaudRate);
}

static uint16_t compute_uart_bd(uint32_t PeriphClk, uint32_t BaudRate)
{
	return ((PeriphClk + (BaudRate/2U))/BaudRate);
}

